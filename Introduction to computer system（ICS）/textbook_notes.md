# 第二章细读

## 前言

补码：two’s complement

浮点运算不可结合，比如（3.14+1e20）-1e20！=3.14+（1e20-1e20）

整数是精确的，但表示范围有限，浮点是近似的，但是表示范围比较广

## 2.1信息存储

字长指明指针的标称大小

注意最高有效位是$x_{\omega-1}$,最低是0，

字节是可寻址的最小单位，因此一个地址+1相当于加了8个bit

void*是一个不表明类型信息的指针

二进制代码是不兼容的，很少能在不同机器上进行移植

注意！！！异或相同取0，不同取1！！！

a&(b|c)=(a&b)|(a&c)

a|(b&c)=(a|b)&(a|c)

注意题目条件是不是对任意字长w都能工作

&&，||，只要算出来就不再继续了

无符号数逻辑右移，有符号数几乎都是算数右移。左移都一样

## 2.2整数表示

long在32位是和int一样，但是64位就能表示一个8字节的数了

<limits.h>里定义了，INT_MAX，INT_MIN，UINT_MAX

<stdint.h>引入整数类型类，intN_t，uintN_t，一般N可以取8,16,32,64

浮点中使用了原码，用首位表示正负

Tmin=-2147483647-1很复杂，不得不

无符号数0扩展，有符号数的符号扩展

先扩展，再进行解释的转换

截断补码，先截断，重新解释成补码



## 2.3整数运算



溢出的和小于任何一个加数

模数加法构成阿贝尔群，是可交换可结合的

无符号数也有逆元，0的就是0，非零的$2^{\omega}$-自己

加法无非就是位模式加完之后直接截断就完事了，只不过解释过程会需要分类讨论

正溢出：++变-；负溢出--变+、

逆元位模式：取反+1，有符号无符号都是，因为逆元本质就是加完是0，而加法就是取决于位模式的，因此逆元也只与位模式有关

位模式取逆元：取反+1或者除了最低位的1以外取反

乘法：完整的位模式可能不同，但是截断后一定相同

整数向零舍入

算数右移是向下舍入，对于负数来说，和整数除法不同，因此要加偏移量

. 







printf("x=%" PRId32 ", y=%" PRIu64 "", x, y);

相同的位模式，无符号和有符号相差0或者$2^{\omega}$,  因此可以用$2^{\omega}-x$的无符号位模式来表示一个负数x的有符号位模式

> 等价地，可以直接按无符号数取反+1的位模式来表示这个位模式
>
> x+(\~x)=二进制为1111...111

补码负数多，反码正数多，原码0多

printf（“0x%04x”，X）%才表示格式，0代表补零，4代表显示4位，x小写代表小写16进制

内存里地址指向小端法最小地址字节（即最低2个16进制位的那个字节）

每次读n个字节就网上取n个字节读出来

1的ASCII码是0x31，A是0x41，a是0x61

异或满足交换律结合律吗？满足，因为事实上一串01列里，配对的00,11都没什么效果，就看最后没配对的0和1的个数，实际上就看这一串里1是奇是偶，是偶取0，是奇取1

注意区分！和~

!!+unsigned会变成有符号数

sizeof（x）返回无符号数

==负奇数除法向0舍入？==

==只要包含unsigned那做完计算就是unsigned，即使原来那个unsigned没有显示地写出来xxxxxu这样==

（\~x）-y=（\~x)+(\~y)+1

小端法高位高地址

大端法高位低地址（背书上图）

数组分配时从低地址到高地址依次递增，每个元素小端法

多元素分配内存时，后来的往小地址放

&，~，^，|排列组合能不能构成完备的

&\~可以实现整个linux，|\~可以，&|不行
## 2.4 浮点
第一位是符号位
前k位指数位：阶码
后面是小数位：尾数
规格化数和非规格化数，NaN，无穷大s11...111000...000
Bias
阶码的值：E=e-Bias

> 最大正非规格化数$(1-2^{-n})*2^{-2^{k-1}+2}$
> 最小正非规格化数$2^{-n}*2^{-2^{k-1}+2}$
> 最大规格数$(2-2^{-n})*2^{2^{k-1}-1}$
> 最小规格数$1*2^{-2^{k-1}+2}$


舍入问题

只有IP地址时大端法，按字节倒置



























取址升级，size变大，*降级，size变小

size计算时要主动讲指针降一级来看

&只能作用在lvalue上，可以出现在赋值语句左边的表达式，包括数据，结构体，联合，数组



# 第三章

过程：一组特定输入+一个可选的返回值的抽象，包括函数，方法等等

过程调用：call+Label，call+*Operand

1. lea不能寻址，那为什么还要用lea？

   > 1. 地址计算
   > 2. can do complex calculations in one instruction
   > 3. one of the only three-operand instructions the x86 has
   > 4. 不改变条件码

2. 

   > CF: 进位，无符号溢出
   >
   > SF:符号
   >
   > ZF：0
   >
   > OF: 有符号溢出

3. test a ,b   <=> b&a 不改变寄存器，只改变条件码

4. ![image-20211012102642134](C:\Users\32959\AppData\Roaming\Typora\typora-user-images\image-20211012102642134.png)

   > 设置寄存器低字节为0or1
   >
   > does not alter remaining 7byte
   >
   > 或者改变内存

5. conditional moves

   > branches are disruptive to instruction flow through pipeline
   >
   > conditional moves ao not require control transfer
   >
   > sometime has bad performance

6. 用条件传送的优劣：

   > 遇到分支如果预测错误会导致很多时间浪费
   >
   > 有时会遇到非法情况（本可以通过条件避免
   >
   > 不总是节省时间



想要对过程进行机器级支持必须处理许多不同的属性：

> 传递控制（程序计数器）
>
> 传递数据（传多参，返回一个数）
>
> 分配和释放内存

重要寄存器：rdi，rsi，rdx，rcx，r8，r9是传入参数，rsp栈指针，rax返回值，rbx，rxp被调用者保存

四字节放入寄存器会把高4字节设置成0

cltq==movslq  %eax %rax（双字到4字）

inc+1

dec-1

neg取负

not取补

cqto（4字到8字）

SF^OF可以表示a-b<0的结果



movabsq只能以寄存器作为目的

movq只能将表示为32位的立即数，符号拓展



栈帧：超出寄存器的存储量，会在栈上分配空间


参数和自己的返回地址算自己的栈帧里，后面就都属于调用的

caller-saved：其他除了%rsp

callee-saved：%rbx，%rbp，%r12到%r15

call：一个push：把返回地址压入栈中，并将PC设为Q的起始地址

call有两种方式，label或者*，直接调用和间接调用

用栈存储的情况：寄存器不够了，有引用必须用地址，用数组和结构



内存到内存和立即数到立即数，立即数不能做目的

条件传送不支持单字节传送

条件传送：不是所有？：语句都能编译成条件传送，因为有可能有安全漏洞（访问本不该访问的内容）涉及到的两个表达式中有一 个出错或者有副作用，用条件传送会导致非法行为





条件传送不总能提高代码效率，毕竟先算了一些东西

条件传送本质是一个算法

条件传送源只能是寄存器或者内存，目的只能是寄存器

条件传送不需要后缀，直接通过目的寄存器判断

递归：每个函数要把母函数的一些参数挂起后再用，用完后pop，这样返回母函数这些变量还是原来的样子

# 常见机器代码的trick

xor  %rax，%rax
> 令%rax清零


mov不能从内存到内存
效率很低，cache不命中，缺页错误，两次缺页错误很不好处理
运算改变条件码

寻址方式：用*%rax，或者访存Imm（base， shift， scale）



## 3.10
### 3.10.4对抗缓冲区溢出攻击
栈随机化：避免安全单一化
用alloca在栈上随机分配字节
空间地址布局随机化ASLR：随机化==程序代码，库代码，栈，全局变量，堆==

空操作雪橇

while, for, if else, switch, break, continue,do while

数据结构的表示，对齐：cache跨block，跨页，SIMD向量操作强制要求
缓冲区溢出







# 第四章
ISA软硬件结合，硬件实现，软件来用
RISC（寻址简单）和CSIC
指令集体系结构：一个处理器支持的指令和指令的字节集编码
Y86-64数据传送要求：
>  源可以是i，r，m，目的只能是r，m
>
> 两个内存传送指令内存引用方式是简单的基址+偏移
>
> 不支持第二变址寄存器和寄存器值的伸缩
>
> 不允许内存到内存（X86-64一样）
>
> 不允许立即数到内存

addq，subq，andq，xorq只对寄存器数据进行操作（X86还对内存）

halt

为什么有些计算时没用的但是还是有execute阶段？

为什么有些指令不把rA，rB空出来？

为什么popq rA要把rsp中的值付给valA和valB?

> 因为valA用来实现取出M中的值
>
> valB要减掉8，后面用
>
> 本质原因是写回阶段有两个任务，但已经经历过execute，必须算好才能用







只有call和jxx会在后面用到valP

三种异常条件+1SAOK：SHLT，SADR，SINS

会从内存读的：

会写入内存的

写入内存的指令*3：rmmovq，push，cal
读内存的指令：mrmovq，pop，ret，
用CC的：cmovxx，jxx
设置CC的：OPq
指令内存不可写？  
只有pop会用到寄存器的两个写端口
dstW的优先级比dstE高，后写入（如果写到相同的地方就会以W为主）



开始：

当流水线的寄存器过多或者寄存器本身的latency过长会有什么结果？

SEQ+改进电路重定时

为什么pC不用硬件寄存器，反而加入了状态寄存器？





ret和条件转移指令没法预测值

高性能处理器会预测ret，到调用后的那条指令，需要一个硬件栈来实现







转发源：e_valE，m_valM，M_valE，W_valM，W_valE

转发目的：valA，valB

如何判断要转发，优先级？

Sel+Fwd A是SelectA的块和转发逻辑的结合

硬件实现，自动！

有些要用的是可知的，有些要用的是不可知的，load_use就是后者的情况

加载互锁



控制冒险：只发生在ret和跳转指令，后者只有在跳转方向预测错误的情况下才会出错
问题：为什么转发不能给PC也安装一个？
什么时候能够发现走错跳转路径了？执行阶段，E的CC代码计算，通过和ifun结合，经过cond，算出CON
跳转只有条件传送和条件跳转，因此e_Cnd走向dstE，M_Cnd走向SelectPC
为什么不把e_Cnd直接传过去？

bubble部分停顿，包含更多的信息，和nop的区别：一个已经进了车库，但是停下了，另一个干脆没有进车库，只是进去一个假的
指令排除
load_use，控制冒险都需要改变控制逻辑
异常指令-》异常处理程序
异常处理逻辑：为什么每个流水线寄存器都要包括一个状态码stat：异常会随着流水线传播，以便出现一个异常就会被记下来不会被修改，并可以确认是哪个值，一路传到下面

需要对任何可能导致程序员可见的操作进行把控，不能让异常出现后仍能写入


PC选择和取指阶段：
PC选择逻辑：根据M_icode,M_Cnd,W_icode,从M_valA,W_valM,pred_PC中选择一个
必须把指令状态和计算分成两部分，取指阶段可以发现非法指令，halt指令，指令地址越界，但是数据地址越界需要访存阶段才能发现
selectPC的优先级？





译码写回阶段：
难点在转发逻辑：
作用：整合valP信号：（ret，popq会把rsp的值作为valA，实际上）并且还会完成转发逻辑，所以比较繁杂
只有call和跳转需要valP的值，记录下一条指令的地址
转发源越接近优先级越高！

执行阶段：
m_stat和W_stat作为输入，决定了是否要更新条件码，如果前面有异常应当停止更新
为什么用e_dstE而不是E_dstE？

访存阶段：
访存：没有data的块，被sel_Fwd A来代替
stat更新只有两处，指令地址越界，非法指令，halt指令在取值阶段

控制逻辑：
load_use暂停一个周期：只有mrmovq和popq rA，再利用转发逻辑
ret：写回阶段才可以（必须访存完）
预测错误：取消指令并从它后面的指令开始执行
异常：禁止更新可见状态，写回阶段要停止执行



# 第5章内容

1.哪里需要优化？

2.如何优化？

> 1.数据结构与算法
> 2.并行计算
> 3.适配编译器
> 4.消除不必要片段
> 5.指令级并行

3.什么情况想优化不能优化？

> 妨碍优化的因素
> 内存别名使用
> 函数副作用
>
> 






# 第6章

## 6.1

### 6.1.2磁盘（Disk）

表面覆盖磁性记录材料

磁盘存储数据可达几百到几千千兆字节，但时间是毫秒级，比DRAM慢10w倍，比SRAM慢100w倍

时间：寻道，旋转，传送

访问磁盘：内存映射，直接内存访问（Direct Memory Access）DMA传送

PCI（peripheral Component Interconnect）外围设备互连

### 6.1.4固态硬盘（Solid State Disk）

基于闪存的技术

读SSD比写要快，以页为单位读，擦除整个页所属的==块==（所有位设为1）才能写

100000次写之后块会被磨损不能使用

闪存翻译层有平均磨损逻辑

SSD是磁盘的重要替代选择

## 6.3存储器层次结构（memory hierarchy）

CPU寄存器（一个时钟周期访问）-基于SRAM的高速缓存存储器（几个T）-基于DRAM的主存（几十到几百T）-本地磁盘-远程服务器上的磁盘

不同层的传送块大小不一样，越底层使用越大的块（访问时间长，一次块太小比较亏）

工作集：一个数组被频繁访问的块的集合：容量不命中（capacity miss）

## 6.4高速缓存寄存器

高速缓存组，高速缓存行，高速缓存块，数据块，有效位，标记位，组索引，块偏移，
直接映射高速缓存，组选择，行匹配，字抽取

组相联高速缓存，相联存储器，全相联高速缓存，只有一个组，没有索引位

直写，写回，修改位，写分配，非写分配

写回通常写分配，因为写回本身就是先更新高速缓存，不得已才动低一层

i-cache，d-cache统一的高速缓存





# 第七章
## 7.1 编译器驱动程序(GCC)
1. 来源：编译系统提供（例如GNU编译系统）
   >  “GNU，名称来自Gnu's Not Unix"的缩写，一个类UNIX的操作系统，由GNU计划推动，目标在于创建一个完全兼容于UNIX的自由软件环境。”  GNU中实现了很多软件，包括GCC编译器。GNU不少软件非常好，但是内核不太行。Linux就是使用了一些里面的函数
2. 作用：代表用户在需要时调用编译器，汇编器，语言预处理器，链接器
3. 过程：
   > .c$\stackrel{c语言预处理器cpp}{\longrightarrow}$.i
   > .i$\stackrel{编译器cc1}{\longrightarrow}$.s(ASCII汇编语言文件)
   > .s$\stackrel{汇编器as}{\longrightarrow}$.o
   > .o$\stackrel{链接器ld}{\longrightarrow}$prog


加载器loader函数：prog代码数据==复制到内存==，将==控制==转移到这个程序的开头
> 
> ###### 补充：
> stdio.h的头文件：很长，.i文件和c文件相差很大
> 没有头文件的文件就没有什么变动！

## 7.2 静态链接
+ 可重定位目标文件->可执行目标文件
+ 符号：函数，全局变量或者静态变量
###### 链接器的任务：
1. 符号解析（每个符号引用要和一个符号定义建立关联）；重定位（符号定义和内存位置相关联）
2. 重定位条目
目标文件是字节块的集合，块中可能有：程序代码，数据，引导链接器和加载器的数据结构

## 7.3 目标文件
1. 可重定位目标文件：二进制代码和数据
2. 可执行目标文件：可直接复制到内存并执行
3. 共享目标文件：一种特殊类型的==可重定位目标文件==，在加载或者运行时可动态地加载到内存并链接

+ 目标模块：字节序列
+ 目标文件：以文件形式存储在磁盘的目标模块
+ 可执行文件被称为a.out文件（早期贝尔实验室第一个Unix系统使用a.out格式作为目标文件格式。
+ Windows：可移植可执行（portable Excutable） PE格式
+ 现代x86-64 Linux和Unix系统使用可执行可链接格式（ELF）

## 7.4 可重定位目标文件
+ ELF头：16字节序列：生成该文件的系统的字的大小和字节顺序，帮助链接器语法分析和解释目标文件的信息（ELF头的大小，目标文件类型，机器类型，节头部表的文件偏移，节头部表表目的大小数量）
+ > type：文件类型：可重定位，可执行，共享文件
+ ![](Image/2021-12-15-23-25-34.png)
+ 每个节都有一个固定大小的条目
+ 节：.text .rodata .data .bss .symtab .rel.text .rel.data .debug .line .strtab
  > + .data:已初始化（非零）的全局变量和静态局部变量
  > + .bss:未初始化的全局变量和静态局部变量和初始化为0的全局变量和静态局部变量(==占位符==)
  > + .symtab:符号表:存放在程序中==定义==和==引用==的函数和全局变量的信息。和编译器不同，这里没有非静态局部变量条目。
  > + .text:机器代码（包含函数类型符号）
  > + .rodata:只读数据，字符串，switch中的跳转表
  > + .rel.text:一个.text节中位置的列表。需要修改的位置。任何调用外部函数或者引用全局函数变量的指令都需要修改位置。
  > + .rel.data:对全局变量调用，需要重定位。
  > + .debug:调试符号表，局部变量和类型定义，程序中定义和引用的全局变量，原始C文件
  > + .line:原始C文件的行号和.text节中机器指令之间的映射
  > + .strtab:字符串表，包括.symtab和.debug节中的符号表，节头部中的节名字
  > + 伪节（节头部表没有条目，仅可重定位目标文件中有）：ABS：不该被重定向的符号；UNDEF：未定义；COMMON：未被分配位置，未初始化的数据目标（value给出对齐要求，size给出最小大小
==注意==：
+ .data：初始化（非零）的静态或全部变量
+ .bss：未初始化或初始化为0的静态变量，初始化为0的全局变量
+ COMMON：未初始化全局变量
+ ==总结==：实际上就是需要占空间的给data，不需要占空间的变量中，弱符号放在COMMON中，其他放到bss中。

## 7.5 符号和符号表

首先明确，符号表是属于可重定义的目标模块的。
> 使用在当前位置之前未定义或者不在该文件的函数，需要声明一下。声明外部函数要加extern关键字。
+ 全局符号：全局变量和非静态的C函数
+ 外部符号：其他模块中定义的全局变量和非静态C函数
+ 局部符号：静态C函数，静态全局变量，静态局部变量。
+ 节名：值为节的起始地址
+ 原始文件路径名的条目
> c变量分为4种：非静态全局变量，静态全局变量，非静态局部变，静态局部变量量。只有局部变量存在内存的栈区，其他存在==内存的静态存储区域==。作用域：非静态全局：全部工程文件都可以用，==静态全局：只有当前文件可以使用==。静态局部：只在定义的函数内有用，函数只分配一次内存，返回后不会消失。非静态局部：每次调用都分配一次内存，返回后就立马消失。==所谓静态，就是隐藏当前范围（模块，函数）内部的变量或者函数，且不被轻易消灭==。静态函数：只在当前文件可见。c++特有：静态数据成员，静态成员函数，这些表示属于一个类但并不属于这个类的任何一个对象。

> 声明：一个变量只能定义一次但可以声明多次，未初始化的全局变量的声明和定义是一样的，因此一个变量的声明往往看不出来是定义还是声明（这也就说明不能有两个强符号，如果有两个强符号，就会出现一个声明一个定义，在链接之前这就已经不被允许了（一个模块内定义重定义）没有额外声明的定义本身定义和声明合为一体，比如很多自定义的函数不需要额外声明。
>  
> 函数的声明往往放到头文件里，定义放到源文件里。
> 

> extern声明：为了只声明不定义，加一个extern就可以。因为很多情况都是声明定义合为一体，无法区分，这导致声明会造成重定义（虽然强弱符号的区分一定程度缓解了这类问题，但仍不能完全解决），因此需要只声明不定义。


==注意==：仅声明没引用的除了==全局变量的非外部声明==都不显示。（全局变量的非外部声明等价于定义）

==注意==：静态局部变量的命名即使一样也会被编译器向汇编器输出两个不同名字的局部符号。保证可区分。

##### 符号表的内容

符号表由汇编器构造。编译器产生的.s文件中本身是有符号表的，但是和汇编器不同，编译器产生的符号表里面多了局部变量的符号。为了区分，可重定位目标文件中的符号我们用==链接器符号==来表示

符号表是由条目数组构成。
条目构成：
> name：字符串表字节偏移
> value：符号的地址（相对于定义目标的节的偏移）
> size：目标的大小
> type：未知or数据or函数，节的条目，原始源文件路径名的条目
> > NOTYPE：未知
> > OBJECT：数据对象，如变量、数组等
> > FUNC：函数或其他可执行代码
> > SECTION：节
> > FILE：文件名
> 
> section：被分配到了哪个节：到节头部表的索引
> binding：本地还是全局
> Ndx:READELF用整数值来表明属于哪个节（.text是第一个节，.rodata是第二个节，.data第三个节。特殊值：ABS：表明这个符号包含了一个绝对的值，比如文件名；COM：表明该符号是一个 COMMON 块符号，一般就是未初始化的全局变量；UND：符号未定义，但是被引用到）

==一些总结==
OBJECT类型的通常放到.data或者.bss或者COMMON
外部符号可以放到UNDEF
函数FUNC一般在.text里
FILE（例如c文件名）一般在ABS节里
节的条目在对应的节中，type是section
![](Image/2021-12-15-23-30-37.png)
## 7.6 符号解析
解析：每个引用个符号表中的定义关联起来
每个局部符号都必须只有一个定义（局部符号包括静态局部变量和静态全局变量）
> ==补充== 
> 作用域：
> c++和java支持重载：重载中函数名和参数列表唯一确定了一个函数（重整，反过来叫恢复）
> 
##### ==总结==
重定义是不允许的，跨文件定义两个同名强全局变量符号也是不允许的。
为了使重定位方便，不同作用域但重名的符号会被编译器取不同的符号名来区分，使用时就近原则（使用当前最近的作用域对应的符号）（当然在重定位时不会关心非静态局部变量）

### 7.6.1解析多重定义的全局符号
目前，每个模块内部的符号已经可以区分，但是模块间还是可能有相同的符号名的全局符号
+ 强符号：==函数==和已初始化的全局变量
+ 弱符号：未初始化的全局变量（COMMON里存着）

强强出错，强弱用强，弱弱选一
> 避免出错可以用GCC-fno-common警告变错误

> 编译器无法区分其他模块有没有弱符号，因此放到COMMON交给链接器来选择




### 7.6.2与静态库链接
静态库：相关的函数被编译为独立的目标模块，封装成单独的静态库文件
静态库可作为链接器的输入，输出的executable file只copy其中被用到的

静态库：相关函数被独立编译成目标模块封装成一个单独的静态库文件

为什么：

> 如果让编译器识别，那么编译器太复杂，每次更新要更新编译器（Pascal）
> 如果把所有标准函数放到一个单独的可重定向的目标模块里，对磁盘空间浪费太大，运行时对内存浪费也巨大，另外标准函数的开发维护也很费时间
> 每个标准函数放到一个可重定向文件里，这样又太多太麻烦了

存档（archive）：静态库的文件格式。一组连接起来的可重定向目标文件的集合。有一个头来描述每个成员目标文件的大小和位置。用.a标识
AR工具生成静态库.a文件
### 7.6.3 链接器如何使用静态库来解析引用
链接器维护：
> 可重定向目标文件的集合E
> 未解析的符号集U
> 已定义符号集D
> 
链接器从左到右扫描编译器驱动程序命令行中的可重定位目标文件和存档文件。
看到目标文件，加入E，更新U，D
看到存档文件，匹配U和存档文件中定义的符号，修改E（某成员被匹配了就加到E），D，U（==这里可能出问题，因为用不用存档里的文件取决于当前的U==）
扫描完U非空就报错

库一般放到命令行的末尾，否则看到库的时候还没看到文件就会出问题
库可以重复使用，可以从根本上解决问题
==可执行文件不必多次使用，因为所有成员都会考虑到==
如果库不相互独立，那么需要把调用别人的放前面，被调用的放后面。（有需求早点出现，免得后面看不到）（或者合并成单独的目标文件）
（为了节约内存，不能把所有库中的东西都拿出来，因此只能麻烦程序员多多考虑）

## 7.7 重定位
步骤：
+ 重定位节和符号定义：合并成==聚合节==并把==运行时内存地址==赋给新的聚合节，原输入节和原输入符号。此时每条指令和全局变量都有了唯一的运行时地址了
+ 重定位节中的符号引用：修改text和data节中对每个符号的引用（依赖重定位条目）

### 7.7.1 重定位条目（确定每个指令，符号的内存位置）
重定位条目：每次遇到对最终位置未知的目标引用就会生成，代码的重定位条目放在.rel.text，已初始化数据的放在.rel.data
> offset：节偏移：修改起始位置相对节的偏移
> type：如何修改（有32种）
> symbol：被修改引用应该指向的符号:目标符号
> addend：对被修改引用的值做偏移调整

两种type：R_X86_64_PC32：重定位一个32位PC相对地址的引用；R_X86_64_32：32位绝对寻址的引用
支持x86_64小型代码模型（GCC默认小型代码模型）

### 7.7.2 重定位符号引用（符号位置已知，确定引用语句的具体位置）



为什么会有addend：因为ADDR(r.symbol)-(ADDR(s)+r.offset)只是计算出相对修改起始位置的偏移，但这是PC往往不是修改起始位置，所以需要减去跳转位置占用的字节数
确定整体偏移后，压入PC作为返回地址，然后修改PC即可。
==注意==
offset是修改其实位置偏移，call，mov指令的后一个字节，因此要加1
call跳转位置是call指令后一个指令的位置（返回值那个地址）+偏移，因此会比重定位引用地址多4字节（或者8字节，取决于大中小代码模型）

因为默认是小型代码模型，只用32位，因此只留4字节的地址来作为跳转目标。

## 7.8 可执行目标文件
+ ELF头：描述文件总体格式，包括程序==入口点（——start函数地址）==（执行的第一条指令的地址）
+ program header table（程序头部表）：描述可执行文件的片到内存的映射关系
+ .init:_init初始化
+ 

可执行文件连续的片（chunk，比如ELF头，程序头部表，init，text，rodata合成一个段：代码段，data，bss合成一个段，数据段）被映射到连续的内存段
bss也会占据内存，但是并不需要从
==偏移对齐：vaddr mod align == off mod align==

## 7.9 加载可执行目标文件
调用加载器（loader，操作系统代码）来运行

execve可以调用加载器
加载器作用：将可执行目标文件中的代码和数据从磁盘复制到内存，通过跳转到程序的第一条指令或入口点来运行该程序
加载：复制到内存并运行
内核：操作系统驻留在内存的部分（不可见）
内存映像：虚拟地址

用户栈：最大合法用户地址：$2^{48}-1$
程序入口:_start, 调用系统启动函数__libc_start_main

从小地址到大地址分别是：代码段（text，rodata，init），数据段（data，bss），运行时堆，共享库的内存映射区，用户栈，内核内存

过程：程序头部表指引加载器将可执行目标文件的chunk复制到代码段和数据段，跳到入口点
## 7.10动态链接共享库

静态库需要更新，每次需要显式地将所有用到程序重新链接而且printf这种每次复制内存过大

动态库：共享目标，用.so表示，是一个目标模块
共享：1.一个文件系统只有一个.so文件，不是每个可执行文件都嵌入一遍；2.内存中共享库的.text可以被不同的进程共享
动态链接器程序实现动态链接（本身是一个共享目标）
-fpic位置无关代码
链接时，不复制代码数据，只是更新重定位和符号表信息





加载过程：先加载部分链接的可执行目标文件，.interp节里有动态链接器的路径名
这时，加载器不在把控制传递给应用，而是加载和运行动态链接器
需要重定位共享库的文本和数据以及对共享库符号的引用
最后将控制传递给应用程序，共享库位置固定
==小结==
此时的动态链接，实际上是把重定位放到加载和运行之间，
## 7.11 从应用程序中加载和链接共享库
现在想在运行时加载和链接共享库，无需在编译时链接
应用：1.分发软件，更新共享库之后下次运行时自动链接和加载新的共享库；2.构建高性能Web服务器，生成动态内容

```cpp
#include<dlfcn.h>
void *dlopen(const char* filename, int flag);
void *dlsym(void* handle, char* symbol);
int dlclose(void* handle);
const char *dlerror(void);
```

## 7.12 位置无关代码

如果动态链接的共享库预先分配内存空间，空间利用率不高，碎片多
位置无关代码（PIC）：可以加载而无需重定位的代码（一旦加载不能再修改的代码段）
> 使用-fpic指示GNU编译系统生成PIC代码，共享库的编译总是使用

在x86-64系统中，对同一个目标模块中符号的引用是不需要特殊处理成为PIC的
可以使用PC相对寻址来编译这些引用，用静态链接器重定位

### 7.12.1 PIC数据引用
目标模块（包括共享）数据段和代码段的相对距离保持不变
任何内存中的目标模块的代码段和数据段的相对位置是固定的：是运行时常量，但整体的位置可能会有变化


全局偏移量表GOT，在数据段开始的地方创建
每个引用全局目标（过程或者全局变量）的目标模块都有自己的GOT条目
编译器为每个GOT条目生成一个重定位记录，GOT表一开始是不知道要填啥的，需要==加载==时重定位
每个引用全局目标的目标模块都有自己的GOT

无论是引用自己还是引用别人，所有引用都用GOT

### 7.12.2PIC函数调用


由于运行时加载到任意位置，因此没法预测函数的地址
一个方法是先生成一个重定位记录，动态链接器在程序加载时再解析它，但这并不是PIC，因为需要修改调用模块的代码段

==延迟绑定==
一个共享库的函数很多，但通常一个程序只用其中的一小部分，因此把函数地址解析推迟到实际被调用的地方
第一次被调用的时候时间开销大，后面只需要一个指令+一个间接引用
使用GOT和PLT过程连接表（代码段的一部分）完成
一个目标模块调用任何函数就有这个函数的GOT和PLT条目


+ PLT[0]：压入重定位条目（GOT[1]）跳转到动态链接器（GOT[2]）
+ PLT[1]：系统启动函数（__libc_start_main）初始化执行环境，调用main并处理其返回值
+ PLT[2]开始就是其他函数对应的条目了
+ GOT[0]：动态链接器在解析函数地址时会用的信息
+ GOT[1]：动态链接器在解析函数地址时会用的信息
+ GOT[2]：动态链接器在ld-linux.so模块的入口点
+ GOT[3]之后就是每个被调用函数的条目


==步骤：==
1. 进入PLT条目，跳到对应GOT条目
2. 第一次会跳回到PLT条目对应的下一个指令
3. 把函数的ID压入栈中（确定是调用哪个函数），跳到PLT[0]
4. PLT[0]通过GOT[1]间接把动态链接器的一个参数压栈（确定重定位条目），通过GOT[2]间接跳转到动态链接器中
5. 动态链接器通过两个栈条目确定函数运行位置，重写GOT对应条目
6. 把控制传递给对应函数

之后再调用，直接从PLT条目到GOT条目并调用函数

## 库打桩机制

截获对共享库函数的调用，取而代之运行自己的代码
作用：追踪某些库函数调用次数，输入输出，甚至完全替换

1. 编译时打桩：-I.参数，C预处理器会在搜索系统目录之前先查当前的头文件，这样可以在头文件中骗过编译器
2. 链接时打桩：静态链接器的支持：--wrap f
3. 运行时打桩：动态链接器的LD_PRELOAD环境变量，共享库路径名列表。先搜索LD_PRELOAD库






## 程序员自我修养部分
### 静态链接：
问什么不直接把文件堆叠起来：很多零散的段造成了空间浪费（In fact, 段的对齐单位是页（4096Byte）
每一个需要重定向的位置都有一个重定向表中的元素与之对应，test，data都可能有
变量类型对于链接器来说是透明的，它只知道名字
弱符号：==未初始化==的==全局变量==（初始化为0的不算弱符号，但是也在.bss中
静态库中一个目标文件只包含一个函数
ld需要什么信息：符号表，重定位表：重定位信息在共享对象中

### 动态链接

静态链接缺点：副本多，占空间，小的改动整个都要改
动态链接：运行时才链接，可拓展性，兼容性
DSO，.so，.dll
动态链接器，装载前链接推迟到装载后
加载时重新链接会导致性能损失，要用延迟绑定来减少
动态链接下有很多==模块==
生成可执行文件时动态链接没有重定位
动态链接器和普通共享对象一样在加载时都会进入进程的地址空间
共享对象在编译时不确定最终的装载地址

装载时重定位，链接时重定位



# 第八章
控制转移：程序计数器的转移
控制流：控制转移序列
异常控制流：控制流突变来应对异常
> 硬件层：硬件出现异常
> 操作系统层：上下文切换
> 应用层：进程间发送信号


## 8.1 异常
异常是异常控制流的一种形式，用来相应处理器状态中的某些变化
异常：控制流的突变
事件：处理器状态发生变化

异常表：一个跳转表。进行==间接过程调用==（没有显示的跳转指令）到异常处理程序


### 8.1.1 异常处理
异常号：每类异常都有唯一异常号（非负整数）
异常号由处理器设计者（除零缺页内存访问违例断点）或者操作系统内核设计者（系统调用，I/O信号）分配
异常表存着异常处理程序的地址
系统启动时操作系统分配和初始化异常表。异常表起始地址存在异常表基址寄存器中（CPU）

异常和过程调用的区别：
+ 返回地址有可能是下一个指令有可能是当前指令有可能不回来
+ 会把额外的处理器状态压到栈里
+ 如果控制转移到内核，压到内核栈而不是用户栈
+ 在内核模式下运行，因此对所有系统资源都有完全的访问权限



并行：并发地运行在不同处理器核


### 8.1.2 异常的类别
interrupt中断：异步，$I_{next}$：执行完当前指令才去处理中断（中断处理程序）（例如I/O信号，时间片到时，断点，网络包）
trap陷阱：$I_{next}$
fault故障：可恢复则处理完返回$I_{now}$重新执行（例如缺页），不可恢复则调用abort，终止（例如除0，segmentation fault）
abort终止：不可恢复致命错误，直接abort不返回（通常硬件错误，例如DRAM，SRAM损坏的奇偶错误
==细节==
I/O设备，例如网络适配器，磁盘控制器，定时器芯片，通过向处理器芯片上的一个引脚发信号，将异常号（标识引起中断的设备）放到系统总线上
中断引脚的电压变高，==当前指令完成后==，注意到中断引脚电压变高，从系统总线上读取异常号，调用适当中断处理程序。
==总结==
只有中断时异步的，其他都是同步的
只有fault并且可修复才会出现异常后返回当前指令的情况


### 常见异常
0~31：处理器设计者分配，故障终止之类的
32-255：操作系统定义：中断或陷阱（都是“有用”的）
除0：浮点异常
一般保护故障：应用未定义虚拟内存区域，写只读文本段（segmentation fault）
机器检查：致命硬件错误


##### 系统调用
也有一个跳转表，每个系统调用对应一个表目
系统级函数：系统调用syscall和他们相关联的包装函数
参数通过寄存器传递
%rax包含系统调用号
%rdi，%rsi，%rdx，%r10，%r8，%r9包含6个参数
返回时%rcx，%r11被破坏，%rax包含返回值，负的表明发生错误，对应负errno

## 8.2 进程

进程：执行中程序的实例。
关键抽象：独立的逻辑控制流，私有的地址空间

上下文：每个进程都有：内核重新启动一个被抢占的进程所需状态
上下文包括代码数据，栈，寄存器内容，程序计数器，环境变量，打开文件描述符集合
逻辑控制流：异常处理程序，进程，信号处理程序，线程m，Java进程
并发：多个流时间上重叠
并行：并发的真子集，并发在不同处理器核或者计算机上
用户模式和内核模式：模式位决定当前的特权，设置这个位就是在内核模式（超级用户模式）
内核模式：可以执行指令集中的任何指令，访问系统中任何内存位置
用户模式：不能执行特权指令（停止处理器，改变模式位，I/O发起，不能直接引用内核区的代码数据
从用户模式到内核模式的唯一方法就是中断，故障，陷入系统调用
/proc文件系统：允许用户模式进程访问内核数据结构的内容，用来找出一般的系统属性
上下文切换：也是异常控制流（高层）：1.保存当前上下文 2.恢复之前被抢占的进程上下文 3.控制传递
上下文切换的时机：内核代表用户执行系统调用（陷阱：sleep，read等），中断（timer）
过程：A用户-A内核-B内核-B用户


## 8.3系统调用错误处理
系统级函数错误返回-1，全局变量errno来存哪里出错了，但是不显式打印的话看不出来是错在哪，甚至不知道错没错。
strerror stderr errno
错误报告函数-》错误处理包装函数
## 8.4 进程控制
PID：每个进程唯一，正数,pid_t类型，在linux在type.h定义为int
进程状态：运行（执行或者等待被执行）停止（挂起不会被调度）终止（永远停止）
子进程：用户级虚拟地址空间相同（独立）的副本，与父进程任何==打开文件描述符==相同的副本（==共享文件==）
回收：进程终止并不直接被内核清除，因为还有可能被其他进程用到，需要被父进程回收
僵死进程：终止未回收的状态
如果父进程提前终止，用init（PID=1，不会终止）来回收
长时间运行的程序：shell，服务器等等，不能等着父进程结束来收子进程，要用函数。
```cpp
#include<sys/types.h>
#include<unistd.h>
#include<sys/wait.h>
pid_t getpid(void);
pid_t getppid(void);
pid_t fork(void);
pid_t waitpid(pid_t pid, int *statusp, int options);
unsigned int sleep(unsigned int secs);
int pause(void);
int execve(const char *filename, const char *argv[], const char* envp[]);
pid_t getpgrp(void);
int setpgid(pid_t pid, pid_t pgid);
#include<stdlib.h>
void exit(int status);
char *getenv(const char *name);
int setenv(const char* name, const char *newvalue, int overwrite);
void unsetenv(const char name);
int parseline(char* buf, char**argv);


#include<sys/types.h>
#include<signal.h>
typedef void(*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
int kill(pid_t pid, int sig);
```

fork特点：调用一次，返回两次；并发执行；相同但独立的地址空间；虚存最开始一样，但是内存不一样，因此是独立的；共享文件
==子进程fork返回0，父进程返回子进程PID非零
waitpid：
> 默认option=0，知道等待集合一个进程结束
> 等待集合：pid>0：单独pid，pid<0，：进程组ID，pid=-1，：父进程全部子进程
> WNOHANG：
> WUNTRACED：
> WCONTINUED：
> WIFEXITED:
> WEXITSTATUS:
> WIFCONTINUED:
> 返回导致返回的子进程PID
> errono:ECHILD,EINTR

execve：在当前的上下文中加载并运行一个新程序
出现错误才会返回，正常调用一次不返回
argv指向一个以NULL结尾的指针数组，argv[0]可执行目标文件名
envp指向一个以NULL结尾的指针数组
指针数组的条目是一个指向字符串的指针

sleep只要接收到一个未被忽略的信号就会自动中断睡眠


控制转移给主函数：
int main(int argc, char *argv[], char* envp[]);
environ:指向envp[0]


### shell
shell是一个交互型的应用级程序，代表用户运行其他程序
shell执行一系列读/求值步骤，然后终止
读步骤读取来自用户的命令行，求值包括解析命令行，代表用户运行程序

parseline最后参数是&则返回1
buildin_command：看第一个是不是shell命令，如果是立刻解析返回1，否则返回0
如果不是内置命令，shell创建一个子进程，前台需要waitpid，否则在后台执行直接重新循环


## 8.5 信号
信号：允许进程和内核中断其他进程，一种高层的软件形式的异常
每个信号对应一种系统事件，底层的硬件异常是由内核处理程序处理的，对用户进程不可见，通过信号，进程就可见这些异常了


### 8.5.1 信号术语
1. 发送信号：系统事件或者进程的kill函数
2. 接收信号：进程被内核强制对信号反应。信号处理程序来捕获信号

pending位向量
blocking位向量


### 8.5.2 发送信号
进程组ID：正整数
父子进程属于一个进程组
/bin/kill -num PID（使用完整路径）
作业：表示为对一条命令行求值而创建的进程，至多只有一个前台作业
Unix管道连接进程成为作业
ctrl+c/z作用于前台作业
kill：pid=0则发给该进程组每一个进程，包括自己
alarm：向自己发送SIGALRM

### 8.5.3 接收信号
signal修改和进程相关联的默认行为，其中SIGSTOP和SIGKILL不可修改
handler：SIG_IGN忽略信号，SIG_DFL：恢复默认
允许同一个处理函数捕获不同的信号   

### 8.5.4 阻塞和解除信号
阻塞是针对信号而言的，不是针对进程而言的，进程只会通过上下文切换，被挂起或者被调度。

阻塞的情况：显式：sigprocmask函数+辅助函数；隐式：默认阻塞当前处理程序正在处理信号类型的待处理信号

### 8.5.5 信号处理程序
1. 安全的信号处理：
   并发运行
   程序尽可能简单，只调用异步安全函数
   保存和恢复errno
   阻塞所有信号，保护对共享全局数据结构的访问
   用volatile声明全局变量：每次从内存读取，不缓存这个变量
   sig_atomic_t：保证是原子的，不可中断的，不需要暂时阻塞，单个的读和写
2. 正确信号处理：不要用信号来计数，因为阻塞情况下，已有待处理信号时，再来信号就会被简单地抛弃
3. 可移植信号处理：Signal包含sigaction，包装好之后避免了不同系统可能出现的问题

### 8.5.6 同步流以避免讨厌的并发错误
通过阻塞一些信号来保证同步
### 8.5.7 显式地等待信号
用while+sigsuspend
## 8.6 非本地跳转
用处：允许深层调用的函数立即返回，不必费力地解开调用栈

允许跳过所有中间调用的特性可能产生意外后果，比如内存泄漏
另一个应用是使一个信号处理返回到特殊代码位置
# 第九章
## 9.1 物理和虚拟地址
编程者角度：地址数组
cpu产生VA，经过MMU变成PA传给主存
## 9.2 地址空间
debug如何操作？？？？
Linear address space
Virtural address space
Physical address space
## 9.3 虚拟内存作为缓存工具
虚拟页的三个子集：未分配的（不占磁盘），缓存的，未缓存的（缓存在内存中）
SRAM缓存：CPU和主存之间的
DRAM缓存；在主存中缓存虚拟页（虚拟页非常大，不是随随便便就能取到没需要缓存）
DRAM的特点：不命中代价非常大！
> 因此：1.虚拟页非常大 2.全相联（物理页可以包含任何虚拟页） 3.替换算法也很精密 4.写回而不是直写（能不写到下一层就不写）

共享库的映射
User cannot access ==privileged kernel information and code==
kernel切掉一部分，其他内存自己分配（大量数据在磁盘）

开机时有个大的表项：huge page 超页
全相联：需要一个大的mapping function
cache中没有mapping function吗？没有

硬件检查是否在内存中，如果没有发现有错误

demanding paging按需调页（但是比较慢
）
page fault是一个异常

PTEs：页表项
硬件实现检查是否可写/可读等等，这些信息来自表项（软件实现）
SUP：requires kernel mode
操作系统建立页表，机制是异常，变到内核态来处理数据
异常处理软件做
## 9.6 地址翻译
过程：从一个虚拟地址找到对应的物理地址并保证缓存以及读取相应数据
命中和不命中
### 9.6.1 结合高速缓存和虚拟内存
区分L1高速缓存和内存和磁盘之间的缓存
TLB：翻译后备缓冲器，缓存页表条目，找一个页表先从缓存中找


==PTE，PTEA，PA，VA，MMU，TLB，VPN，VPO，PPO，PPN，PTBR==

高级页表是可以在需要时创建，页面调入，页面调出的，这样只有用到才会出现在内存中

### 9.6.4 综合：端到端的地址翻译



## 9.7.2 Linux虚拟内存系统


## 9.9 动态内存分配
动态内存分配器维护堆
### 9.9.4 碎片
内部碎片和外部碎片
### 9.9.5 实现问题
空闲块放置
放置
分割
合并
### 9.9.6 隐式空闲链表
块的大小：头部+有效载荷+填充


明确：页表项是做什么的？把VPN和PPN对应
PLT：翻译后备缓存器：缓存PTE
没缓存就要去内存找到并缓存，怎么找：多级页表，从第一个页表开始一个一个找直到找到PTEA，如果找不到，就得去把相应高层页表调入。找到最后
找到PPN就算找到了绝对实际物理地址，后面就是正常操作




# 第十章
## 10.2 文件
普通文件，文本文件，二进制文件，对内核而言，二进制文件和文本文件没有区别
目录：/根目录，~home
套接字
## 10.3 打开关闭文件
文件描述符int
文件位置：相对字节偏移量




filename，flag（如何访问）， mode（访问权限）
每个进程都有一个umask
open返回ssize_t: unsigned_long, 输入size_t：long

Robust I/O: 

读取元数据：stat和fstat检索关于文件的信息（matadata）

描述符表，文件表，v-node表



GOT：全局偏移量表、

慢速系统调用read write

>  https://blog.csdn.net/benkaoya/article/details/17262053

malloc要判断是不是空

不用用int因为会传入负的

不要写弱符号：static int x或者int x=0不要写int x

局部变量初始化

# 第十一章 网络编程
问题：如果自己和自己连接如何走

加LAN2帧头时用到了包头？

## 11.1 客户端-服务端编程模型


客户端-服务器模型：一个服务器管理资源，和多个客户端间执行事务
事务：1.客户端请求 2.服务器解释，操作资源 3.服务器相应 4.客户端接收处理

==服务器，客户端都是进程！！！==
服务器客户端运行在主机上，一般是不同主机

## 11.2网络
每个适配器有一个全球唯一的48位地址

IP TCP UDP

主机-》IP地址：32位无符号整数
因特网域名


步骤：
1. 在系统调用时从虚拟地址空间读取
2. 在协议软件上打包成包含包的帧传，到LAN1适配器
3. 适配器复制到该帧的网络上
4. 寻找到路由器
5. 路由器上的LAN1适配器解析读取并送给协议软件换头
6. LAN2适配器复制到该帧的网络上
7. 传给主机B的LAN2网络适配器并传给协议软件
8. 通过协议软件剥落头，系统调用时给到虚拟地址空间

对主机：网络又是一种I/O设备
网络适配器插在I/O总线拓展槽中的网络适配器额物理接口中
DMA传送（直接存储器访问）：适配器到内存or内存到适配器

桥可以学会选择最好的路线来更好地利用带宽
路由器：对各种局域网和广域网购进互联网络

协议：1.提供命名机制（互联网络地址唯一标识每一台主机） 2.提供传送机制

把数据捆扎成包，包有包头（目的和源主机的地址，大小），有效载荷（源主机发出的数据位）


LAN：局域网：典型以太网
以太网段：电缆，集线器，端口，用集线器和相同带宽的电缆组织起来主机
桥接以太网：大一点的局域网，用网桥链接以太网段
互联网络：广域网，由路由器连接不同局域网，广域网行程的
## 11.3全球IP因特网 Internet


主机字节顺序（小端法，用h表示）
网络字节顺序（大端法，用n表示）
点分十进制表示法

htonl ntohl inet_pton inet_ntop
TPC/IP协议：传输控制协议，互联网络协议
IP：提供基本的命名方法和传送机制。不会试图恢复丢掉的包，不可靠。
UDP：不可靠数据报协议：拓展IP，可以在进程间而不只是主机间传递包
TCP：构建在IP上的复杂协议，提供进程间可靠的全双工连接
主机用32位IP地址标识
IP映射到互联网域名标识符
能够通过连接和任何主机进行进程间通信

### 11.3.1 IP地址
唯一一个用到大端法的

点分十进制表示法

### 11.3.2 因特网域名

子域
DNS数据库包含了非常多的主机条目结构：域名和IP地址的等价类
回送地址127.0.0.1
### 11.3.3 因特网链接
套接字是连接的端点
套接字地址：地址+端口
临时端口：客户端的端口，内核分配
知名端口：服务器中的端口，和服务相对应
每个知名端口的服务都有一个对应的知名服务名

一个连接是由套接字对来唯一确定的
## 11.4 套接字接口
是一组函数，和UnixI/O联合使用，来创建网络应用


内核：套接字是端点
用户：套接字是由文件描述符的打开文件

客户端主动，服务器被动
listen：主动套接字到监听套接字
accept：等待来自客户端的请求
connect：客户端调用建立和服务器的连接
bind：服务器内核将addr中的服务器套接字地址和套接字描述符sockfd联系起来
getaddrinfo函数：
## 11.5 WEB服务器
HTTP：基于文本的用户级协议
超文本传输协议
Web内容可以用HTML超文本标记语言来编写
内容：MIME多用途的网际扩充协议类型的字节序列
静态内容，动态内容
URL：通用资源定位符


TELNET执行事务
HTTP标准：文本行/r/n结尾
请求行，请求报头
URI：统一资源标识符，是URL的后缀

代理缓存：浏览器和服务器的中介
Host报头指示了原始服务器的域名

CGI：通用网关接口
服务器收到GET请求，调用fork和execve在子进程上下文运行请求的程序
叫做CGI程序，也叫做CGI脚本

# 第12章 并发编程

并发：逻辑控制流在时间上重叠
并行：不同设备或者不同核，是并发的真子集
线程：切换更有效率，但容易出错，共享数据更容易
进程：共享信息困难，效率低
访问慢速I/O设备 
与人交互
推迟工作降低延迟
服务多个网络客户端
多核机器并发编程





进程间通信IPC：控制流相互通信，需要显示进行

## 12.3 线程
线程上下文：线程ID，栈，栈指针，程序计数器，通用目的寄存器，条件码
进程上下文中共享的：堆，代码，数据，共享库，打开文件

一个线程可以杀死任何对等线程，或者wait其他线程


线程可结合，分离的

分离的不能被回收或者杀死，系统自动释放这个线程

一个可结合线程，要么被显示回收，要么被分离


同步错误



读者写者问题
写者改数据，读栈，
读者，read on no writer,可以read together

一个互斥锁不够

cnt
改动cnt还需要一个互斥锁
写者一直写
写者write也需要一个互斥锁



1.信号量semaphove













# 不懂
右值引用
是不是要分类讨论大端法和小端法？
32位机器代表了什么

using namespace std：c++语言提供一个全局的命名空间namespace，可以避免导致全局命名冲突问题。

> https://blog.csdn.net/slj_win/article/details/26351419

GCC用printf不需要加头文件

但是vscode用的是g++

windows里面c和c++混用

c不支持STL库

GNU是什么？

# 

# 其他

加减法比>,<,<<,>>优先级高

malloc函数：memory allocation

```c++

.h文件不能定义变量
.c放到头文件实际上和当前文件将来会属于同一个模块。

void *malloc(size_t size)
```

返回指针指向分配好的内存

考动态链接
网络不考大题

周末补课，

# 指令
```cpp
objdump -r xxx.o 重定位表

readelf -s xxx.o 符号表

ar 压缩
```


# 小班课
为什么没有内存道内存的指令：两边都可能有page fault
没法区分page fault在哪步发出的

cache disable 
PTEs

协议：

边缘网络
核心网络
调制解调器
防火墙 NAT：内网自己用

传输：比特流，有guided和unguided
Coaxial铜线，光纤


半双工
无线受环境影响
wifi半双工
satellite
Network core


TCP两端确定：HTTP使用，可靠的链接，没有状态，不能记录你是谁

IP

UDP不管
